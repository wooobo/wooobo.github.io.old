---
title: "JPA - 연관관계 알아보기"
layout: archive
date: 2021-11-15
---

<br> 

> 학습목적으로 작성되어 다소 부적확한 내용이 있을 수 있습니다. 

# 예제로 사용해볼 관계도

![img.png]({{ "assets/images/jpa-1.png" | relative_url }})

`User(유저)`테이블 과 `Post(게시물)` 테이블이 있습니다.
이때 `유저`는 여러개 의 `게시물`을 작성 할 수 있습니다.


위의 테이블 구조로는 `유저`가 작성한 `게시물`이 어떤것 인지 알수 없습니다.  
그래서 이때 relation id 를 둘중 하나의 테이블에 저장 해두어야 합니다.

![img.png]({{ "assets/images/jpa-2.png" | relative_url }})

한명의 `User` 가 여러개의 `Post` 를 가질 수 있으므로, `Post` 테이블에 관계 ID를 저장하도록 변경합니다.
`Post` 테이블에 `user_id` 컬럼은 `User` 테이블의 고유 `id`입니다.  

## 데이터

- User 테이블

|id|name|password|
|------|---|---|
|1|name1|pass1|
|2|name2|pass2|
|3|name3|pass3|

- Post 테이블

|id|user_id|title|contents|
|------|---|---|
|1|3|제목 123|내용|
|1|3|제목 748|내용|
|2|1|제목 189|내용|
|3|2|제목 1894|내용|
|3|2|제목 181|내용|

```sql

# user.id 가 "1" 인 post 찾기 쿼리  
select post from post where post.user_id = 1;

# post 테이블에서 "post.user_id = 1" 조건으로 user 데이터 가져오기
select user from post join user on post.user_id = user.id where post.user_id = 1;

# user 테이블에서 "user.id = 1" 조건으로 post 데이터 가져오기
select post from user join post on user.id = post.user_id where user.id =1; 

```

DB 에서는 한쪽 테이블에서 Relation Id(관계 ID)를 가지고 있어도 양방향 조회가 가능합니다.    


## 객체 관점에서 보기


```java

@Entity
@Table(name = "user")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "name", unique = true, length = 20, nullable = false)
    private String name;

    @Column(name = "password", length = 20, nullable = false)
    private String password;
    
    @OneToMany(mappedBy = "user")
    private List<Post> posts = new ArrayList<>();
    
    protected User() {
    }

    public User(String name, String password) {
        this.name = name;
        this.password = password;
    }

}

```

```java 


@Entity
@Table(name = "post")
public class Post {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "title", length = 100, nullable = false)
    String title;

    @Lob
    @Column(name = "contents")
    private String contents;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", foreignKey = @ForeignKey(name = "fk_post_user"))
    private User user;

    private Post() {
    }

    public Post( String title, String contents) {
        this.title = title;
        this.contents = contents;
    }
    
    public void toUser(User user) {
        this.user = user;
    }
}

```

앞서 DB 에서는 어느 한쪽에 연관 ID 를 가지고있으면 양방향으로 조회가되는것을 확인했었습니다.  
하지만 객체입장에서는 양방향이라는 것이 존재하지 않습니다.  단방향만 존재 할 뿐입니다.
여기서 단방향 관계란, 한쪽의 Entity 에서만 참조 되고있는 것을 말합니다.  
양방향 관계란, 양쪽 Entity 서로 참조 되고 있는 것을 말합니다.

위의 Entity 코드는 `User` -> `Post` , `Post` -> `User` 어느 Entity 에서든 서로 접근이 가능하기 때문에 양방향 참조 중입니다.

연관 관계 코드는 아래 두 부분입니다.

```java

** User entity
@OneToMany(mappedBy = "user")
private List<Post> posts = new ArrayList<>();


** Post entity
@ManyToOne(fetch = FetchType.LAZY) 
@JoinColumn(name = "user_id", foreignKey = @ForeignKey(name = "fk_post_user"))
private User user;

```

- `mappedBy` 옵션은 주인 테이블을 지정해주는 역할합니다. Post entity 에서 설정 되어있는 `user`를 지정합니다.
- `@JoinColumn` 으로 연관 관계 컬럼을 지정합니다. 연관 관계 컬럼은 `user_id`으로 설정합니다.

만약 `User entity` 에서 `@OneToMany`를 제거 한다면, `Post`->`User`의 단방향 관계로만 맵핑됩니다.  
보통은 처음에는 모두 단방향 관계로 설계했다가 프로젝트가 진행하면서 양방향으로 뚫어야 할때 그때 양방향으로 하는것을 지향한다고 합니다.
 
> [토크ON 41차. JPA 프로그래밍 기본기 다지기 T아카데미](https://www.youtube.com/playlist?list=PL9mhQYIlKEhfpMVndI23RwWTL9-VL-B7U)  
> 영상을 통해 자세한 기본 개념을 익히는데 도움이 됩니다.  

## DDL 문 확인하기

sql 출력 로그를 확인하기 위해 Spring 프로젝트의 `application.properties` 파일에 아래같이 설정합니다.  
H2 테스트 디비와 , sql 출력 설정입니다.
```text
spring.datasource.url=jdbc:h2:~/test;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
spring.datasource.username=sa
spring.h2.console.enabled=true

spring.jpa.properties.hibernate.format_sql=true
spring.jpa.show-sql=true
logging.level.org.hibernate.type.descriptor.sql=trace
```

위 코드를 실행하고, DDL 문 출력 결과입니다.

```sql
create table post (
  id bigint generated by default as identity,
  contents clob,
  title varchar(100) not null,
  user_id bigint,
  primary key (id)
)

create table user (
  id bigint generated by default as identity,
  name varchar(20) not null,
  password varchar(20) not null,
  primary key (id)
)

# 유니크 설정 SQL 입니다.
alter table user 
  add constraint UK_gj2fy3dcix7ph7k8684gka40c unique (name)

# foregin key 설정입니다. 
# `@JoinColumn(name = "user_id", foreignKey = @ForeignKey(name = "fk_post_user"))` 설정 으로 발생하는 쿼리 입니다.
alter table post 
  add constraint fk_post_user 
  foreign key (user_id) 
  references user
```
> JPA 굳... 어노테이션 맵핑했을 뿐인데 DB 에 해당 부분에 맞추어 만들어줍니다!

### Entity Test 코드로 하나씩 짚어보기

#### 1. 양방향 맵핑시 무한루프 문제

양방향 맵핑시 무한루프가 문제가 발생 할 수 있습니다.  
코드 부터 보겠습니다. 

```java
@Test
void user_to_save_post() {
    // 1. new User
    User user = new User("name1", "PASSWORD!!");

    // 2. new Post
    Post post = new Post("제목", "내용입니다.");
    post.toUser(user);
      
    // 3. user.addPost()
    user.addPost(post);

    // 4. post.getUser()
    System.out.println(post.getUser()); // 무한 루프 발생 
}


# 콘솔 로그 
java.lang.StackOverflowError
	at com.example.jpaexamples.domain.User.toString(User.java:59)
	at java.base/java.lang.String.valueOf(String.java:2951)
	at com.example.jpaexamples.domain.Post.toString(Post.java:57)
	at java.base/java.lang.String.valueOf(String.java:2951)
	at java.base/java.lang.StringBuilder.append(StringBuilder.java:168)
	at java.base/java.util.AbstractCollection.toString(AbstractCollection.java:473)
	at java.base/java.lang.String.valueOf(String.java:2951)
```

`post.getUser()` 를 출력하려는데 `StackOverflowError`에러가 발생합니다.  
이유는 post -> user -> post -> user 계속해서 참조 객체를 찾으려 해서 문제가 발생 한것으로 보여집니다.  
이때에는 `toString()` 메소드를 수정해주어야 합니다.  

```java

# User
    @Override
    public String toString() {
        return "User{" +
            "id=" + id +
            ", name='" + name + '\'' +
            ", password='" + password + '\'' +
            ", posts='" + posts + '\'' +  =========================> 제거
            '}';
    }
    
# POST
    @Override
    public String toString() {
        return "Post{" +
            "id=" + id +
            ", title='" + title + '\'' +
            ", contents='" + contents + '\'' +
            ", user='" + user + '\'' +   ===========================> 제거
            '}';
    }

```

#### 2. 편의메소드 


```java 
@Test
void 편의메소드_예제() {
    // 1. new User
    User user = new User("name1", "PASSWORD!!");

    // 2. new Post
    Post post = new Post("제목", "내용입니다.");
    post.toUser(user);

    // 3. user.getPosts();
    System.out.println(user.getPosts());  ====> 결과 : []
}
```

`Post` 생성자를 통해 `user`참조 객체를 전달해주었습니다. `user.getPosts()` 출력은 [] 비어 있습니다.  
당연...하지만 편의메소드를 알아보기위한 예제입니다. ㅎ    
보시는것과 같이 객체는 단방향개념 밖에 없습니다. 그래서 객체입장에서는 양방향 관계라기 보다는 양방향 관계인것 처럼 만들어 주어야 합니다.

- 편의 메소드 리팩토링

```java 

@Entity
@Table(name = "post")
public class Post {
    ...
    
    public void toUser(User user) {
        user.addPost(this);
        this.user = user;
    }
    
    ...
```

`toUser` 메소드에 `user.addPost(this);` `user` 객체에도 자신(`post`)을 추가해주는 코드를 추가해줍니다. 이제 `post.toUser(user)` 메소드를 호출 하게 되면 `post` 객체에도 추가되고 `user` 객체에도 추가하도록 해주는게 `편의메소드`입니다.

수정 후 테스트 코드를 다시 실행 해보면 `user` 객체에도 추가된것을 확인 할 수 있습니다.

```shell
// 3. user.getPosts();
System.out.println(user.getPosts()); // [Post{id=null, title='제목', contents='내용입니다.'}]
```

### JpaRepository Test 

이제는 JpaRepository 테스트를 통해 데이터를 insert, select 테스트를 해보며 학습해보겠습니다.
간단하게 짚고만 넘어가겠습니다. `JpaRepository` 는 Entity 클래스를 CRUD 뿐만 `Query Methods`를 
사용하여 DB 쿼리를 만들어주어 추가,업데이트,삭제를 손쉽게 사용 할 수 있는 인터페이스입니다.
(다음에 자세하게 다루어 보겠습니다..)

[Spring Data JPA 문서](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#preface)


#### Entity 레포지토리 만들기

보통은 `{Entity Name}Repository` 의 형태로 이름을 정하고,   
`public interface {Entity Name}Repository extends JpaRepository<T, ID>` 의 형태로 레포지토리를 생성합니다.

```java
#  UserRepository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByName(String name);
}

# PostRepository
public interface PostRepository extends JpaRepository<Post, Long> {
    Optional<Post> findByTitle(String title);
}
```

#### JPA 테스트 하기

`@DataJpaTest` 를 사용하면 손쉽게 테스트를 진행 할 수 있습니다. 

``` java
@DataJpaTest
public class RepositoryTest {

    @Autowired
    UserRepository userRepository;

    @Autowired
    PostRepository postRepository;

}
```


- User 생성

```java
@Test
void user_save() {
    User user = new User("name1", "PASSWORD!!"); // (1) 비영속
    userRepository.save(user); // (2) 영속
}

# 출력 SQL
Hibernate: 
    insert 
    into
        user
        (id, name, password) 
    values
        (null, ?, ?)
        
binding parameter [1] as [VARCHAR] - [name1]
binding parameter [2] as [VARCHAR] - [PASSWORD!!]
```

(1) 은 비영속 상태로 `entityManage` 에게 매니징 되고 있는 아닌 상태입니다. (2) 에서 `save(entity)` 를 호출하게 되면 
DB에 `flush` 하게 되어 DB insert 가 보내지게 됩니다.  
여기서 말하는 `영속`, `비영속`은 엔티티 생명주기라고 하는데요.  
엔티티 생명주기에는
1. 비영속(new/transient): 영속성 컨텍스트와 전혀 관계가 없는 상태
2. 영속(managed): 영속성 컨텍스트에 저장된 상태
3. 준영속(detached): 영속성 컨텍스트에 저장되었다가 분리된 상태
4. 삭제(removed): 삭제된 상태

그럼 영속성 컨텍스트는 뭘까요... ㅜㅜ?  
우선은 업데이트 테스트 부터 보겠습니다.

```shell
@Test
void user_update() {
    User user = new User("name1", "PASSWORD!!");
    System.out.println("log (1)");
    User savedUser = userRepository.save(user);
    
    System.out.println("log (2)");
    savedUser.setName("이름 변경");
    
    System.out.println("log (3)");
    userRepository.flush();
}

# log 
log (1)
Hibernate: 
    insert 
    into
        user
        (id, name, password) 
    values
        (null, ?, ?)
log (2)
log (3)
Hibernate: 
    update
        user 
    set
        name=?,
        password=? 
    where
        id=?
```

log 찍힌걸 보면,   
`User savedUser = userRepository.save(user);` 으로 통해 `insert query` 가 commit 됩니다.  
이때 `savedUser` 는 영속성을 가지는 객체입니다.  
`savedUser.setName("이름 변경")` 반응없고,   
`userRepository.flush()` 에서 업데이트 쿼리가 commit 됩니다.    
`savedUser`는 엔티티매니져(영속컨텍스트)에 의해 관리 되고 있는 상태입니다.   
그래서 커밋 시점에 변경된 부분이 있으면 해당 부분을 DB 에 반영시키는 쿼리를 보냅니다.  

더 자세한 설명은...  
![img.png]({{ "assets/images/오늘은여기까지.png" | relative_url }}){: width="200"}  
자세한 설명은 잘 정리된 블로그 링크로 대체하겠습니다. [링크](https://siyoon210.tistory.com/138)


아직 작성중.....